---
// This component is the contianer for most of the app
// The cards will be displayed on top of this container
// And will be able to be dragged and dropped on top of this container
---

<svg
  class="graph-container"
  id="graph-container"
  xmlns="http://www.w3.org/2000/svg"
  width="100%"
  height="100%"
>
  <defs>
    <pattern
      id="smallGrid"
      width="10"
      height="10"
      patternUnits="userSpaceOnUse"
    >
      <path d="M 10 0 L 0 0 0 10" fill="none" stroke="gray" stroke-width="0.5"
      ></path>
    </pattern>
    <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
      <rect width="100" height="100" fill="url(#smallGrid)"></rect>
      <!-- <path d="M 100 0 L 0 0 0 100" fill="none" stroke="gray" stroke-width="1"
      ></path> -->
    </pattern>
  </defs>

  <rect width="100%" height="100%" fill="url(#grid)"></rect>
  <g id="content">
    <slot />
  </g>
</svg>

<style>
  .graph-container {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    overflow: auto;
  }
</style>

<script lang="js">
  let svg, pt, downPoint, lastPoint, transform;
  document.addEventListener("DOMContentLoaded", function () {
    svg = document.getElementById("graph-container");
    pt = svg.createSVGPoint();
    svg.setAttribute("transform", "translate(0, 0) scale(1)");

    svg.addEventListener("mousedown", startDrag);
    svg.addEventListener("mousemove", drag);
    svg.addEventListener("mouseup", endDrag);
    svg.addEventListener("mouseleave", endDrag);
    svg.addEventListener("wheel", zoom);
  });

  function startDrag(evt) {
    downPoint = getPointFromEvent(evt);
    lastPoint = downPoint;
  }

  function drag(evt) {
    if (!downPoint) return;
    const point = getPointFromEvent(evt);
    const { x, y } = getSVGTranslation();
    const dx = point.x - lastPoint.x;
    const dy = point.y - lastPoint.y;
    setSVGTranslation(x + dx, y + dy);
    lastPoint = point;
  }

  function endDrag() {
    downPoint = null;
  }

  function zoom(evt) {
    evt.preventDefault();
    console.log("OLA");
    const point = getPointFromEvent(evt);
    const delta = Math.max(-1, Math.min(1, evt.wheelDelta || -evt.detail));
    const scale = Math.pow(1.1, delta);
    const { x, y } = getSVGTranslation();
    const newX = x - point.x * (scale - 1);
    const newY = y - point.y * (scale - 1);
    const newScale = getSVGScale() * scale;
    setSVGTranslation(newX, newY);
    setSVGScale(newScale);
  }

  function getPointFromEvent(evt) {
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  function getSVGTranslation() {
    const transform = svg.getAttribute("transform");
    const translate = transform.match(/translate\(([^)]+)\)/)[1].split(" ");
    return { x: parseFloat(translate[0]), y: parseFloat(translate[1]) };
  }

  function setSVGTranslation(x, y) {
    const scale = getSVGScale();
    svg.setAttribute("transform", `translate(${x}, ${y}) scale(${scale})`);
  }

  function getSVGScale() {
    const transform = svg.getAttribute("transform");
    return parseFloat(transform.match(/scale\(([^)]+)\)/)[1]);
  }

  function setSVGScale(scale) {
    const { x, y } = getSVGTranslation();
    svg.setAttribute("transform", `translate(${x}, ${y}) scale(${scale})`);
  }
</script>
